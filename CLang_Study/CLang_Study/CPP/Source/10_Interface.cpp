#include "stdafx.h"
#include "10_Interface.h"

void Interface() 
{
	Weapon* sword = new Sword;
	Weapon* bow = new Bow;

	sword->Attack();
	bow->Attack();

	delete sword;
	delete bow;
}

/*
Interface : 인터페이스
- 클래스의 일종으로, 추상적인 기능만 정의한 클래스
- 함수 선언만을 하고, 함수의 구현은 파생 클래스에게 담당
- 클래스의 결합도를 낮추고, 유지보수를 용이하게 해주는 역할
- 다중 상속에서의 다이아몬드 상속 문제를 해결하기 위해 사용
- 순수 가상 함수로만 이루어져 있으므로, 객체를 생성할 수 없음 (추상 클래스)
- 파생 클래스에서 인터페이스를 상속받을 때는, 인터페이스에서 정의한 함수를 반드시 정의해야 함 

인터페이스를 언제 쓰면 좋을까?
1. 다형성 구현
- 캐릭터 인터페이스를 정의하고 각 캐릭터 클래스에서 이를 상속받아 캐릭터의 공격, 이동 등 다양한 기능을 다르게 구현할 수 있음
2. 코드의 유연성과 확장성 향상
- 플러그인 시스템에서는 인터페이스를 정의하고 이를 구현한 다른 모듈을 로드하여 사용할 수 있음
3. 외부 라이브러리와의 인터페이스
- 외부 라이브러리와의 상호작용을 위해 인터페이스를 사용하는 경우가 있음
- 외부 라이브러리에서 제공하는 인터페이스를 구현함으로써 라이브러리와 소프트웨어 간의 결합도를 낮출 수 있음
4. 다른 프로그래머와의 협업
- 인터페이스를 사용하여 작업의 분담과 코드 간의 결합도를 낮춤으로써 협업을 쉽게 할 수 있음

클래스 간의 결합도
- 한 클래스가 다른 클래스에 의존하는 정도
- 결합도가 높을수록 클래스간의 의존도가 높아짐
- 코드 유지보수 및 확장이 어려워짐
- 결합도를 낮춘다
	- 한 클래스가 다른 클래스에 의존하는 정도를 최소화하여 두 클래스 간의 의존성을 줄이는 것
	- 하나의 클래스의 변경이 다른 클래스에 미치는 영향을 최소화
	- 코드 유지보수 및 확장이 용이
	- 추상화, 캡슐화, 인터페이스 등의 개념을 적극 활용하여 구현할 수 있음

- 다이아몬드 상속 문제
- 다이아몬드 모양으로 클래스간의 상속 관계가 구성될 때
- 다중 상속 구조에서 중복 상속되는 클래스의 멤버 변수나 함수가 중복 정의되어 충돌하는 문제를 일으키는 것을 의미

상속 vs 인터페이스
- 클래스 간의 결합도를 낮추고 다형성을 지원해야 함 -> 인터페이스
- 가상 함수를 사용하여 다형성을 지원하고 상속을 활용하여 기능을 확장해야 함 -> 상속
*/